PROVING ceval_deterministic'
ATTEMPTED THEOREM PROOF (LEMMAS USED: 0)







From Coq Require Import Lia.
From Coq Require Import Arith.Arith.
From Coq Require Import Arith.PeanoNat.
Import Nat.
From Coq Require Import Arith.EqNat.
From LF Require Import Imp Maps.



Fixpoint ceval_step1 (st : state) (c : com) : state :=
  match c with
    | <{ skip }> =>
        st
    | <{ l := a1 }> =>
        (l !-> aeval st a1 ; st)
    | <{ c1 ; c2 }> =>
        let st' := ceval_step1 st c1 in
        ceval_step1 st' c2
    | <{ if b then c1 else c2 end }> =>
        if (beval st b)
          then ceval_step1 st c1
          else ceval_step1 st c2
    | <{ while b1 do c1 end }> =>
        st  
  end.








Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=
  match i with
  | O => empty_st
  | S i' =>
    match c with
      | <{ skip }> =>
          st
      | <{ l := a1 }> =>
          (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          let st' := ceval_step2 st c1 i' in
          ceval_step2 st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step2 st c1 i'
            else ceval_step2 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then let st' := ceval_step2 st c1 i' in
               ceval_step2 st' c i'
          else st
    end
  end.



Fixpoint ceval_step3 (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          match (ceval_step3 st c1 i') with
          | Some st' => ceval_step3 st' c2 i'
          | None => None
          end
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step3 st c1 i'
            else ceval_step3 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then match (ceval_step3 st c1 i') with
               | Some st' => ceval_step3 st' c i'
               | None => None
               end
          else Some st
    end
  end.



Notation "'LETOPT' x <== e1 'IN' e2"
   := (match e1 with
         | Some x => e2
         | None => None
       end)
   (right associativity, at level 60).

Fixpoint ceval_step (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          LETOPT st' <== ceval_step st c1 i' IN
          ceval_step st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step st c1 i'
            else ceval_step st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then LETOPT st' <== ceval_step st c1 i' IN
               ceval_step st' c i'
          else Some st
    end
  end.

Definition test_ceval (st:state) (c:com) :=
  match ceval_step st c 500 with
  | None    => None
  | Some st => Some (st X, st Y, st Z)
  end.

Example example_test_ceval :
     test_ceval empty_st

     <{ X := 2;
        if (X <= 1)
        then Y := 3
        else Z := 4
        end }>

     = Some (2, 0, 4).
Proof. reflexivity. Qed.



Definition pup_to_n : com
  := <{ Y := 0;
        while X > 0 do
          Y := Y + X;
          X := X - 1
        end }>.

Example pup_to_n_1 :
  test_ceval (X !-> 5) pup_to_n
  = Some (0, 15, 0).
Proof. reflexivity. Qed.




Definition peven : com
  := <{ Z := 0;
        while X > 0 do
          if Z = 0 then Z := 1 else Z := 0 end;
          X := X - 1
        end }>.

Example peven0 :
  test_ceval (X !-> 0) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven1 :
  test_ceval (X !-> 1) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven2 :
  test_ceval (X !-> 2) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven3 :
  test_ceval (X !-> 3) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven4 :
  test_ceval (X !-> 4) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.






Theorem ceval_step__ceval: forall c st st',
      (exists i, ceval_step st c i = Some st') ->
      st =[ c ]=> st'.
Proof.
  intros c st st' H.
  inversion H as [i E].
  clear H.
  generalize dependent st'.
  generalize dependent st.
  generalize dependent c.
  induction i as [| i' ].

  - 
    intros c st st' H. discriminate H.

  - 
    intros c st st' H.
    destruct c;
           simpl in H; inversion H; subst; clear H.
      +  apply E_Skip.
      +  apply E_Asgn. reflexivity.

      + 
        destruct (ceval_step st c1 i') eqn:Heqr1.
        * 
          apply E_Seq with s.
            apply IHi'. rewrite Heqr1. reflexivity.
            apply IHi'. assumption.
        * 
          discriminate H1.

      + 
        destruct (beval st b) eqn:Heqr.
        * 
          apply E_IfTrue. rewrite Heqr. reflexivity.
          apply IHi'. assumption.
        * 
          apply E_IfFalse. rewrite Heqr. reflexivity.
          apply IHi'. assumption.

      +  destruct (beval st b) eqn :Heqr.
        * 
         destruct (ceval_step st c i') eqn:Heqr1.
         { 
           apply E_WhileTrue with s. rewrite Heqr.
           reflexivity.
           apply IHi'. rewrite Heqr1. reflexivity.
           apply IHi'. assumption. }
         {  discriminate H1. }
        * 
          injection H1 as H2. rewrite <- H2.
          apply E_WhileFalse. apply Heqr. Qed.






Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None.


Theorem ceval_step_more: forall i1 i2 st st' c,
  i1 <= i2 ->
  ceval_step st c i1 = Some st' ->
  ceval_step st c i2 = Some st'.
Proof.
induction i1 as [|i1']; intros i2 st st' c Hle Hceval.
  - 
    simpl in Hceval. discriminate Hceval.
  - 
    destruct i2 as [|i2']. inversion Hle.
    assert (Hle': i1' <= i2') by lia.
    destruct c.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. simpl.
      destruct (ceval_step st c1 i1') eqn:Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        discriminate Hceval.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); apply (IHi1' i2') in Hceval;
        assumption.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); try assumption.
      destruct (ceval_step st c i1') eqn: Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite -> Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        simpl in Hceval. discriminate Hceval.  Qed.



Theorem ceval__ceval_step: forall c st st',
      st =[ c ]=> st' ->
      exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st' Hce.
  induction Hce.
  - exists 1. reflexivity.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2].
    exists (S i + j).
    assert (H: ceval_step st c1 (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    simpl. rewrite H. apply ceval_step_more with (i1:=j).
    rewrite plus_comm. apply le_plus_l. apply IH2.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2]. exists (S i + j). simpl. rewrite H.
    assert (G: ceval_step st c (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    rewrite G. apply ceval_step_more with (i1:=j). apply le_plus_r. apply IH2.
Qed.


Theorem ceval_and_ceval_step_coincide: forall c st st',
      st =[ c ]=> st'
  <-> exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st'.
  split. apply ceval__ceval_step. apply ceval_step__ceval.
Qed.








Theorem ceval_deterministic' : forall c st st1 st2,
     st =[ c ]=> st1 ->
     st =[ c ]=> st2 ->
     st1 = st2.

Proof.
(* We will proceed by induction on the number of steps taken by the ceval_step relation.
*)
  intros c st st1 st2 H1 H2.
(* We first show that if st1 and st2 are related by the ceval_step relation for 0 steps, then they are equal.
*)
  assert (H3 : st1 = st2) as H3.
{ apply ceval_step_0_eq; assumption.
}
  (* Now, we will use the induction hypothesis to prove the statement for the next step.
*)
  assert (H4 : st =[ c ]=> st1') as H4.
{ apply H1; assumption.
}
  assert (H5 : st =[ c ]=> st2') as H5.
{ apply H2; assumption.
}
  (* We now have to show that st1' and st2' are equal.
We do this by applying the induction hypothesis.
*)
  assert (H6 : st1' = st2') as H6.
{ apply IHceval_deterministic; assumption.
}
  (* Finally, we can conclude the proof by applying the equality we have shown.
*)
  rewrite H3 in H6.
reflexivity.
Qed.

Outdated contents in ..cache: recomputing
ERROR MESSAGE IN THEOREM PROOF (FRAGMENT #464)
Error after step "intros c st st1 st2 H1 H2.".
Message: There are still unproven goals.
Goal: st1 = st2.


TRYING TO PROVE LEMMA
Lemma state_determinism_0 : forall c : com, forall st st1 st2 : state, forall H1 : st =[ c ]=> st1, forall H2 : st =[ c ]=> st2, st1 = st2.


ATTEMPTED LEMMA PROOF (LEMMAS USED: 1)







From Coq Require Import Lia.
From Coq Require Import Arith.Arith.
From Coq Require Import Arith.PeanoNat.
Import Nat.
From Coq Require Import Arith.EqNat.
From LF Require Import Imp Maps.



Fixpoint ceval_step1 (st : state) (c : com) : state :=
  match c with
    | <{ skip }> =>
        st
    | <{ l := a1 }> =>
        (l !-> aeval st a1 ; st)
    | <{ c1 ; c2 }> =>
        let st' := ceval_step1 st c1 in
        ceval_step1 st' c2
    | <{ if b then c1 else c2 end }> =>
        if (beval st b)
          then ceval_step1 st c1
          else ceval_step1 st c2
    | <{ while b1 do c1 end }> =>
        st  
  end.








Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=
  match i with
  | O => empty_st
  | S i' =>
    match c with
      | <{ skip }> =>
          st
      | <{ l := a1 }> =>
          (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          let st' := ceval_step2 st c1 i' in
          ceval_step2 st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step2 st c1 i'
            else ceval_step2 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then let st' := ceval_step2 st c1 i' in
               ceval_step2 st' c i'
          else st
    end
  end.



Fixpoint ceval_step3 (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          match (ceval_step3 st c1 i') with
          | Some st' => ceval_step3 st' c2 i'
          | None => None
          end
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step3 st c1 i'
            else ceval_step3 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then match (ceval_step3 st c1 i') with
               | Some st' => ceval_step3 st' c i'
               | None => None
               end
          else Some st
    end
  end.



Notation "'LETOPT' x <== e1 'IN' e2"
   := (match e1 with
         | Some x => e2
         | None => None
       end)
   (right associativity, at level 60).

Fixpoint ceval_step (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          LETOPT st' <== ceval_step st c1 i' IN
          ceval_step st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step st c1 i'
            else ceval_step st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then LETOPT st' <== ceval_step st c1 i' IN
               ceval_step st' c i'
          else Some st
    end
  end.

Definition test_ceval (st:state) (c:com) :=
  match ceval_step st c 500 with
  | None    => None
  | Some st => Some (st X, st Y, st Z)
  end.

Example example_test_ceval :
     test_ceval empty_st

     <{ X := 2;
        if (X <= 1)
        then Y := 3
        else Z := 4
        end }>

     = Some (2, 0, 4).
Proof. reflexivity. Qed.



Definition pup_to_n : com
  := <{ Y := 0;
        while X > 0 do
          Y := Y + X;
          X := X - 1
        end }>.

Example pup_to_n_1 :
  test_ceval (X !-> 5) pup_to_n
  = Some (0, 15, 0).
Proof. reflexivity. Qed.




Definition peven : com
  := <{ Z := 0;
        while X > 0 do
          if Z = 0 then Z := 1 else Z := 0 end;
          X := X - 1
        end }>.

Example peven0 :
  test_ceval (X !-> 0) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven1 :
  test_ceval (X !-> 1) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven2 :
  test_ceval (X !-> 2) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven3 :
  test_ceval (X !-> 3) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven4 :
  test_ceval (X !-> 4) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.






Theorem ceval_step__ceval: forall c st st',
      (exists i, ceval_step st c i = Some st') ->
      st =[ c ]=> st'.
Proof.
  intros c st st' H.
  inversion H as [i E].
  clear H.
  generalize dependent st'.
  generalize dependent st.
  generalize dependent c.
  induction i as [| i' ].

  - 
    intros c st st' H. discriminate H.

  - 
    intros c st st' H.
    destruct c;
           simpl in H; inversion H; subst; clear H.
      +  apply E_Skip.
      +  apply E_Asgn. reflexivity.

      + 
        destruct (ceval_step st c1 i') eqn:Heqr1.
        * 
          apply E_Seq with s.
            apply IHi'. rewrite Heqr1. reflexivity.
            apply IHi'. assumption.
        * 
          discriminate H1.

      + 
        destruct (beval st b) eqn:Heqr.
        * 
          apply E_IfTrue. rewrite Heqr. reflexivity.
          apply IHi'. assumption.
        * 
          apply E_IfFalse. rewrite Heqr. reflexivity.
          apply IHi'. assumption.

      +  destruct (beval st b) eqn :Heqr.
        * 
         destruct (ceval_step st c i') eqn:Heqr1.
         { 
           apply E_WhileTrue with s. rewrite Heqr.
           reflexivity.
           apply IHi'. rewrite Heqr1. reflexivity.
           apply IHi'. assumption. }
         {  discriminate H1. }
        * 
          injection H1 as H2. rewrite <- H2.
          apply E_WhileFalse. apply Heqr. Qed.






Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None.


Theorem ceval_step_more: forall i1 i2 st st' c,
  i1 <= i2 ->
  ceval_step st c i1 = Some st' ->
  ceval_step st c i2 = Some st'.
Proof.
induction i1 as [|i1']; intros i2 st st' c Hle Hceval.
  - 
    simpl in Hceval. discriminate Hceval.
  - 
    destruct i2 as [|i2']. inversion Hle.
    assert (Hle': i1' <= i2') by lia.
    destruct c.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. simpl.
      destruct (ceval_step st c1 i1') eqn:Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        discriminate Hceval.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); apply (IHi1' i2') in Hceval;
        assumption.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); try assumption.
      destruct (ceval_step st c i1') eqn: Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite -> Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        simpl in Hceval. discriminate Hceval.  Qed.



Theorem ceval__ceval_step: forall c st st',
      st =[ c ]=> st' ->
      exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st' Hce.
  induction Hce.
  - exists 1. reflexivity.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2].
    exists (S i + j).
    assert (H: ceval_step st c1 (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    simpl. rewrite H. apply ceval_step_more with (i1:=j).
    rewrite plus_comm. apply le_plus_l. apply IH2.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2]. exists (S i + j). simpl. rewrite H.
    assert (G: ceval_step st c (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    rewrite G. apply ceval_step_more with (i1:=j). apply le_plus_r. apply IH2.
Qed.


Theorem ceval_and_ceval_step_coincide: forall c st st',
      st =[ c ]=> st'
  <-> exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st'.
  split. apply ceval__ceval_step. apply ceval_step__ceval.
Qed.








Lemma state_determinism_0 : forall c : com, forall st st1 st2 : state, forall H1 : st =[ c ]=> st1, forall H2 : st =[ c ]=> st2, st1 = st2.

Proof.
(* We will proceed by induction on the structure of the command c.
*)
  intros c st st1 st2 H1 H2.
induction c; intros; try (constructor); auto.
(* Case skip *)
  (* Case l := a1 *)
  (* Case c1 ; c2 *)
  (* Case if b then c1 else c2 end *)
  (* Case while b1 do c1 end *)
  (* We will use the premise H1 and H2 to rewrite the terms st1 and st2 *)
  (* Then we will use the equality of states to prove the goal *)
  (* We will also use the fact that the commands are deterministic, i.e., they will always lead to the same final state given the same initial state *)
  (* This will be done by applying the theorems ceval_step__ceval, ceval_step_more, and ceval__ceval_step *)
  (* The proof will be by case analysis on the possible values of ceval_step st c i *)
  (* Case None *)
  (* Case Some st' *)
  (* We will use the fact that the commands are deterministic to prove the goal in both cases *)
  (* This will be done by applying the theorems ceval_step__ceval, ceval_step_more, and ceval__ceval_step *)
  (* The proof will be by case analysis on the possible values of ceval_step st c i *)
  (* Case None *)
  (* Case Some st' *)
  (* We will use the fact that the commands are deterministic to prove the goal in both cases *)
  (* This will be done by applying the theorems ceval_step__ceval, ceval_step_more, and ceval__ceval_step *)
  (* The proof will be by case analysis on the possible values of ceval_step st c i *)
  (* Case None *)
  (* Case Some st' *)
  (* We will use the fact that the commands are deterministic to prove the goal in both cases *)
  (* This will be done by applying the theorems ceval_step__ceval, ceval_step_more, and ceval__ceval_step *)
  (* The proof
Qed.

Outdated contents in ..cache: recomputing
ERROR MESSAGE IN LEMMA PROOF (FRAGMENT #466)
Error after step "induction c; intros; try (constructor); auto.".
Message: There are still unproven goals.
Goal: st1 = st2.


TRYING TO PROVE LEMMA
Lemma state_equality_after_skip_1 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, st1 = st2.


ATTEMPTED LEMMA PROOF (LEMMAS USED: 2)







From Coq Require Import Lia.
From Coq Require Import Arith.Arith.
From Coq Require Import Arith.PeanoNat.
Import Nat.
From Coq Require Import Arith.EqNat.
From LF Require Import Imp Maps.



Fixpoint ceval_step1 (st : state) (c : com) : state :=
  match c with
    | <{ skip }> =>
        st
    | <{ l := a1 }> =>
        (l !-> aeval st a1 ; st)
    | <{ c1 ; c2 }> =>
        let st' := ceval_step1 st c1 in
        ceval_step1 st' c2
    | <{ if b then c1 else c2 end }> =>
        if (beval st b)
          then ceval_step1 st c1
          else ceval_step1 st c2
    | <{ while b1 do c1 end }> =>
        st  
  end.








Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=
  match i with
  | O => empty_st
  | S i' =>
    match c with
      | <{ skip }> =>
          st
      | <{ l := a1 }> =>
          (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          let st' := ceval_step2 st c1 i' in
          ceval_step2 st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step2 st c1 i'
            else ceval_step2 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then let st' := ceval_step2 st c1 i' in
               ceval_step2 st' c i'
          else st
    end
  end.



Fixpoint ceval_step3 (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          match (ceval_step3 st c1 i') with
          | Some st' => ceval_step3 st' c2 i'
          | None => None
          end
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step3 st c1 i'
            else ceval_step3 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then match (ceval_step3 st c1 i') with
               | Some st' => ceval_step3 st' c i'
               | None => None
               end
          else Some st
    end
  end.



Notation "'LETOPT' x <== e1 'IN' e2"
   := (match e1 with
         | Some x => e2
         | None => None
       end)
   (right associativity, at level 60).

Fixpoint ceval_step (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          LETOPT st' <== ceval_step st c1 i' IN
          ceval_step st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step st c1 i'
            else ceval_step st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then LETOPT st' <== ceval_step st c1 i' IN
               ceval_step st' c i'
          else Some st
    end
  end.

Definition test_ceval (st:state) (c:com) :=
  match ceval_step st c 500 with
  | None    => None
  | Some st => Some (st X, st Y, st Z)
  end.

Example example_test_ceval :
     test_ceval empty_st

     <{ X := 2;
        if (X <= 1)
        then Y := 3
        else Z := 4
        end }>

     = Some (2, 0, 4).
Proof. reflexivity. Qed.



Definition pup_to_n : com
  := <{ Y := 0;
        while X > 0 do
          Y := Y + X;
          X := X - 1
        end }>.

Example pup_to_n_1 :
  test_ceval (X !-> 5) pup_to_n
  = Some (0, 15, 0).
Proof. reflexivity. Qed.




Definition peven : com
  := <{ Z := 0;
        while X > 0 do
          if Z = 0 then Z := 1 else Z := 0 end;
          X := X - 1
        end }>.

Example peven0 :
  test_ceval (X !-> 0) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven1 :
  test_ceval (X !-> 1) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven2 :
  test_ceval (X !-> 2) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven3 :
  test_ceval (X !-> 3) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven4 :
  test_ceval (X !-> 4) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.






Theorem ceval_step__ceval: forall c st st',
      (exists i, ceval_step st c i = Some st') ->
      st =[ c ]=> st'.
Proof.
  intros c st st' H.
  inversion H as [i E].
  clear H.
  generalize dependent st'.
  generalize dependent st.
  generalize dependent c.
  induction i as [| i' ].

  - 
    intros c st st' H. discriminate H.

  - 
    intros c st st' H.
    destruct c;
           simpl in H; inversion H; subst; clear H.
      +  apply E_Skip.
      +  apply E_Asgn. reflexivity.

      + 
        destruct (ceval_step st c1 i') eqn:Heqr1.
        * 
          apply E_Seq with s.
            apply IHi'. rewrite Heqr1. reflexivity.
            apply IHi'. assumption.
        * 
          discriminate H1.

      + 
        destruct (beval st b) eqn:Heqr.
        * 
          apply E_IfTrue. rewrite Heqr. reflexivity.
          apply IHi'. assumption.
        * 
          apply E_IfFalse. rewrite Heqr. reflexivity.
          apply IHi'. assumption.

      +  destruct (beval st b) eqn :Heqr.
        * 
         destruct (ceval_step st c i') eqn:Heqr1.
         { 
           apply E_WhileTrue with s. rewrite Heqr.
           reflexivity.
           apply IHi'. rewrite Heqr1. reflexivity.
           apply IHi'. assumption. }
         {  discriminate H1. }
        * 
          injection H1 as H2. rewrite <- H2.
          apply E_WhileFalse. apply Heqr. Qed.






Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None.


Theorem ceval_step_more: forall i1 i2 st st' c,
  i1 <= i2 ->
  ceval_step st c i1 = Some st' ->
  ceval_step st c i2 = Some st'.
Proof.
induction i1 as [|i1']; intros i2 st st' c Hle Hceval.
  - 
    simpl in Hceval. discriminate Hceval.
  - 
    destruct i2 as [|i2']. inversion Hle.
    assert (Hle': i1' <= i2') by lia.
    destruct c.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. simpl.
      destruct (ceval_step st c1 i1') eqn:Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        discriminate Hceval.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); apply (IHi1' i2') in Hceval;
        assumption.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); try assumption.
      destruct (ceval_step st c i1') eqn: Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite -> Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        simpl in Hceval. discriminate Hceval.  Qed.



Theorem ceval__ceval_step: forall c st st',
      st =[ c ]=> st' ->
      exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st' Hce.
  induction Hce.
  - exists 1. reflexivity.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2].
    exists (S i + j).
    assert (H: ceval_step st c1 (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    simpl. rewrite H. apply ceval_step_more with (i1:=j).
    rewrite plus_comm. apply le_plus_l. apply IH2.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2]. exists (S i + j). simpl. rewrite H.
    assert (G: ceval_step st c (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    rewrite G. apply ceval_step_more with (i1:=j). apply le_plus_r. apply IH2.
Qed.


Theorem ceval_and_ceval_step_coincide: forall c st st',
      st =[ c ]=> st'
  <-> exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st'.
  split. apply ceval__ceval_step. apply ceval_step__ceval.
Qed.








Lemma state_equality_after_skip_1 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, st1 = st2.

Proof.
(*
    We will proceed by induction on the relation st =[ c ]=> st'.
The base case will be when c is skip.
In this case, we have H1 : st =[ skip ]=> st1 and H2 : st =[ skip ]=> st2.
We need to prove st1 = st2.
By the definition of ceval_step, we have st1 = st.
Similarly, by the definition of ceval_step, we have st2 = st.
Therefore, st1 = st2.
*)
  intros st st1 st2 H1 H2.
inversion H1.
inversion H2.
reflexivity.
Qed.

Outdated contents in ..cache: recomputing
ERROR MESSAGE IN LEMMA PROOF (FRAGMENT #468)
Error in step "reflexivity.".
Message: In environment
st, st1, st2 : state
H1 : st =[ skip ]=> st1
H2 : st =[ skip ]=> st2
st0 : state
H0 : st0 = st
H3 : st = st1
st3 : state
H4 : st3 = st
H5 : st = st2
Unable to unify "st2" with "st1"..
Goal: st1 = st2.


TRYING TO PROVE LEMMA
Lemma state_equality_preserved_by_skip_transition_2 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, forall st0 : state, forall H0 : st0 = st, forall H3 : st = st1, forall st3 : state, forall H4 : st3 = st, forall H5 : st = st2, st1 = st2.


ATTEMPTED LEMMA PROOF (LEMMAS USED: 3)







From Coq Require Import Lia.
From Coq Require Import Arith.Arith.
From Coq Require Import Arith.PeanoNat.
Import Nat.
From Coq Require Import Arith.EqNat.
From LF Require Import Imp Maps.



Fixpoint ceval_step1 (st : state) (c : com) : state :=
  match c with
    | <{ skip }> =>
        st
    | <{ l := a1 }> =>
        (l !-> aeval st a1 ; st)
    | <{ c1 ; c2 }> =>
        let st' := ceval_step1 st c1 in
        ceval_step1 st' c2
    | <{ if b then c1 else c2 end }> =>
        if (beval st b)
          then ceval_step1 st c1
          else ceval_step1 st c2
    | <{ while b1 do c1 end }> =>
        st  
  end.








Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=
  match i with
  | O => empty_st
  | S i' =>
    match c with
      | <{ skip }> =>
          st
      | <{ l := a1 }> =>
          (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          let st' := ceval_step2 st c1 i' in
          ceval_step2 st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step2 st c1 i'
            else ceval_step2 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then let st' := ceval_step2 st c1 i' in
               ceval_step2 st' c i'
          else st
    end
  end.



Fixpoint ceval_step3 (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          match (ceval_step3 st c1 i') with
          | Some st' => ceval_step3 st' c2 i'
          | None => None
          end
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step3 st c1 i'
            else ceval_step3 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then match (ceval_step3 st c1 i') with
               | Some st' => ceval_step3 st' c i'
               | None => None
               end
          else Some st
    end
  end.



Notation "'LETOPT' x <== e1 'IN' e2"
   := (match e1 with
         | Some x => e2
         | None => None
       end)
   (right associativity, at level 60).

Fixpoint ceval_step (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          LETOPT st' <== ceval_step st c1 i' IN
          ceval_step st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step st c1 i'
            else ceval_step st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then LETOPT st' <== ceval_step st c1 i' IN
               ceval_step st' c i'
          else Some st
    end
  end.

Definition test_ceval (st:state) (c:com) :=
  match ceval_step st c 500 with
  | None    => None
  | Some st => Some (st X, st Y, st Z)
  end.

Example example_test_ceval :
     test_ceval empty_st

     <{ X := 2;
        if (X <= 1)
        then Y := 3
        else Z := 4
        end }>

     = Some (2, 0, 4).
Proof. reflexivity. Qed.



Definition pup_to_n : com
  := <{ Y := 0;
        while X > 0 do
          Y := Y + X;
          X := X - 1
        end }>.

Example pup_to_n_1 :
  test_ceval (X !-> 5) pup_to_n
  = Some (0, 15, 0).
Proof. reflexivity. Qed.




Definition peven : com
  := <{ Z := 0;
        while X > 0 do
          if Z = 0 then Z := 1 else Z := 0 end;
          X := X - 1
        end }>.

Example peven0 :
  test_ceval (X !-> 0) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven1 :
  test_ceval (X !-> 1) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven2 :
  test_ceval (X !-> 2) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven3 :
  test_ceval (X !-> 3) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven4 :
  test_ceval (X !-> 4) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.






Theorem ceval_step__ceval: forall c st st',
      (exists i, ceval_step st c i = Some st') ->
      st =[ c ]=> st'.
Proof.
  intros c st st' H.
  inversion H as [i E].
  clear H.
  generalize dependent st'.
  generalize dependent st.
  generalize dependent c.
  induction i as [| i' ].

  - 
    intros c st st' H. discriminate H.

  - 
    intros c st st' H.
    destruct c;
           simpl in H; inversion H; subst; clear H.
      +  apply E_Skip.
      +  apply E_Asgn. reflexivity.

      + 
        destruct (ceval_step st c1 i') eqn:Heqr1.
        * 
          apply E_Seq with s.
            apply IHi'. rewrite Heqr1. reflexivity.
            apply IHi'. assumption.
        * 
          discriminate H1.

      + 
        destruct (beval st b) eqn:Heqr.
        * 
          apply E_IfTrue. rewrite Heqr. reflexivity.
          apply IHi'. assumption.
        * 
          apply E_IfFalse. rewrite Heqr. reflexivity.
          apply IHi'. assumption.

      +  destruct (beval st b) eqn :Heqr.
        * 
         destruct (ceval_step st c i') eqn:Heqr1.
         { 
           apply E_WhileTrue with s. rewrite Heqr.
           reflexivity.
           apply IHi'. rewrite Heqr1. reflexivity.
           apply IHi'. assumption. }
         {  discriminate H1. }
        * 
          injection H1 as H2. rewrite <- H2.
          apply E_WhileFalse. apply Heqr. Qed.






Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None.


Theorem ceval_step_more: forall i1 i2 st st' c,
  i1 <= i2 ->
  ceval_step st c i1 = Some st' ->
  ceval_step st c i2 = Some st'.
Proof.
induction i1 as [|i1']; intros i2 st st' c Hle Hceval.
  - 
    simpl in Hceval. discriminate Hceval.
  - 
    destruct i2 as [|i2']. inversion Hle.
    assert (Hle': i1' <= i2') by lia.
    destruct c.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. simpl.
      destruct (ceval_step st c1 i1') eqn:Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        discriminate Hceval.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); apply (IHi1' i2') in Hceval;
        assumption.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); try assumption.
      destruct (ceval_step st c i1') eqn: Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite -> Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        simpl in Hceval. discriminate Hceval.  Qed.



Theorem ceval__ceval_step: forall c st st',
      st =[ c ]=> st' ->
      exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st' Hce.
  induction Hce.
  - exists 1. reflexivity.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2].
    exists (S i + j).
    assert (H: ceval_step st c1 (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    simpl. rewrite H. apply ceval_step_more with (i1:=j).
    rewrite plus_comm. apply le_plus_l. apply IH2.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2]. exists (S i + j). simpl. rewrite H.
    assert (G: ceval_step st c (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    rewrite G. apply ceval_step_more with (i1:=j). apply le_plus_r. apply IH2.
Qed.


Theorem ceval_and_ceval_step_coincide: forall c st st',
      st =[ c ]=> st'
  <-> exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st'.
  split. apply ceval__ceval_step. apply ceval_step__ceval.
Qed.








Lemma state_equality_preserved_by_skip_transition_2 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, forall st0 : state, forall H0 : st0 = st, forall H3 : st = st1, forall st3 : state, forall H4 : st3 = st, forall H5 : st = st2, st1 = st2.

Proof.
intros st st1 st2 H1 H2 st0 H0 H3 st3 H4 H5.
(* We first prove that st1 = st3 *)
  assert (H6 : st1 = st3) as H6.
{
    apply H0;
    apply H3;
    apply H4.
}
  (* We then prove that st2 = st3 *)
  assert (H7 : st2 = st3) as H7.
{
    apply H5;
    apply H3;
    apply H4.
}
  (* We now prove that st1 = st2 *)
  apply H6;
  apply H7.
Qed.

Outdated contents in ..cache: recomputing
ERROR MESSAGE IN LEMMA PROOF (FRAGMENT #464)
Error after step "intros st st1 st2 H1 H2 st0 H0 H3 st3 H4 H5.".
Message: There are still unproven goals.
Goal: st1 = st2.


TRYING TO PROVE LEMMA
Lemma state_equality_preserved_by_skip_transition_3 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, forall st0 : state, forall H0 : st0 = st, forall H3 : st = st1, forall st3 : state, forall H4 : st3 = st, forall H5 : st = st2, st1 = st2.


ATTEMPTED LEMMA PROOF (LEMMAS USED: 4)







From Coq Require Import Lia.
From Coq Require Import Arith.Arith.
From Coq Require Import Arith.PeanoNat.
Import Nat.
From Coq Require Import Arith.EqNat.
From LF Require Import Imp Maps.



Fixpoint ceval_step1 (st : state) (c : com) : state :=
  match c with
    | <{ skip }> =>
        st
    | <{ l := a1 }> =>
        (l !-> aeval st a1 ; st)
    | <{ c1 ; c2 }> =>
        let st' := ceval_step1 st c1 in
        ceval_step1 st' c2
    | <{ if b then c1 else c2 end }> =>
        if (beval st b)
          then ceval_step1 st c1
          else ceval_step1 st c2
    | <{ while b1 do c1 end }> =>
        st  
  end.








Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=
  match i with
  | O => empty_st
  | S i' =>
    match c with
      | <{ skip }> =>
          st
      | <{ l := a1 }> =>
          (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          let st' := ceval_step2 st c1 i' in
          ceval_step2 st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step2 st c1 i'
            else ceval_step2 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then let st' := ceval_step2 st c1 i' in
               ceval_step2 st' c i'
          else st
    end
  end.



Fixpoint ceval_step3 (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          match (ceval_step3 st c1 i') with
          | Some st' => ceval_step3 st' c2 i'
          | None => None
          end
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step3 st c1 i'
            else ceval_step3 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then match (ceval_step3 st c1 i') with
               | Some st' => ceval_step3 st' c i'
               | None => None
               end
          else Some st
    end
  end.



Notation "'LETOPT' x <== e1 'IN' e2"
   := (match e1 with
         | Some x => e2
         | None => None
       end)
   (right associativity, at level 60).

Fixpoint ceval_step (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          LETOPT st' <== ceval_step st c1 i' IN
          ceval_step st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step st c1 i'
            else ceval_step st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then LETOPT st' <== ceval_step st c1 i' IN
               ceval_step st' c i'
          else Some st
    end
  end.

Definition test_ceval (st:state) (c:com) :=
  match ceval_step st c 500 with
  | None    => None
  | Some st => Some (st X, st Y, st Z)
  end.

Example example_test_ceval :
     test_ceval empty_st

     <{ X := 2;
        if (X <= 1)
        then Y := 3
        else Z := 4
        end }>

     = Some (2, 0, 4).
Proof. reflexivity. Qed.



Definition pup_to_n : com
  := <{ Y := 0;
        while X > 0 do
          Y := Y + X;
          X := X - 1
        end }>.

Example pup_to_n_1 :
  test_ceval (X !-> 5) pup_to_n
  = Some (0, 15, 0).
Proof. reflexivity. Qed.




Definition peven : com
  := <{ Z := 0;
        while X > 0 do
          if Z = 0 then Z := 1 else Z := 0 end;
          X := X - 1
        end }>.

Example peven0 :
  test_ceval (X !-> 0) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven1 :
  test_ceval (X !-> 1) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven2 :
  test_ceval (X !-> 2) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven3 :
  test_ceval (X !-> 3) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven4 :
  test_ceval (X !-> 4) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.






Theorem ceval_step__ceval: forall c st st',
      (exists i, ceval_step st c i = Some st') ->
      st =[ c ]=> st'.
Proof.
  intros c st st' H.
  inversion H as [i E].
  clear H.
  generalize dependent st'.
  generalize dependent st.
  generalize dependent c.
  induction i as [| i' ].

  - 
    intros c st st' H. discriminate H.

  - 
    intros c st st' H.
    destruct c;
           simpl in H; inversion H; subst; clear H.
      +  apply E_Skip.
      +  apply E_Asgn. reflexivity.

      + 
        destruct (ceval_step st c1 i') eqn:Heqr1.
        * 
          apply E_Seq with s.
            apply IHi'. rewrite Heqr1. reflexivity.
            apply IHi'. assumption.
        * 
          discriminate H1.

      + 
        destruct (beval st b) eqn:Heqr.
        * 
          apply E_IfTrue. rewrite Heqr. reflexivity.
          apply IHi'. assumption.
        * 
          apply E_IfFalse. rewrite Heqr. reflexivity.
          apply IHi'. assumption.

      +  destruct (beval st b) eqn :Heqr.
        * 
         destruct (ceval_step st c i') eqn:Heqr1.
         { 
           apply E_WhileTrue with s. rewrite Heqr.
           reflexivity.
           apply IHi'. rewrite Heqr1. reflexivity.
           apply IHi'. assumption. }
         {  discriminate H1. }
        * 
          injection H1 as H2. rewrite <- H2.
          apply E_WhileFalse. apply Heqr. Qed.






Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None.


Theorem ceval_step_more: forall i1 i2 st st' c,
  i1 <= i2 ->
  ceval_step st c i1 = Some st' ->
  ceval_step st c i2 = Some st'.
Proof.
induction i1 as [|i1']; intros i2 st st' c Hle Hceval.
  - 
    simpl in Hceval. discriminate Hceval.
  - 
    destruct i2 as [|i2']. inversion Hle.
    assert (Hle': i1' <= i2') by lia.
    destruct c.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. simpl.
      destruct (ceval_step st c1 i1') eqn:Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        discriminate Hceval.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); apply (IHi1' i2') in Hceval;
        assumption.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); try assumption.
      destruct (ceval_step st c i1') eqn: Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite -> Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        simpl in Hceval. discriminate Hceval.  Qed.



Theorem ceval__ceval_step: forall c st st',
      st =[ c ]=> st' ->
      exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st' Hce.
  induction Hce.
  - exists 1. reflexivity.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2].
    exists (S i + j).
    assert (H: ceval_step st c1 (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    simpl. rewrite H. apply ceval_step_more with (i1:=j).
    rewrite plus_comm. apply le_plus_l. apply IH2.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2]. exists (S i + j). simpl. rewrite H.
    assert (G: ceval_step st c (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    rewrite G. apply ceval_step_more with (i1:=j). apply le_plus_r. apply IH2.
Qed.


Theorem ceval_and_ceval_step_coincide: forall c st st',
      st =[ c ]=> st'
  <-> exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st'.
  split. apply ceval__ceval_step. apply ceval_step__ceval.
Qed.








Lemma state_equality_preserved_by_skip_transition_3 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, forall st0 : state, forall H0 : st0 = st, forall H3 : st = st1, forall st3 : state, forall H4 : st3 = st, forall H5 : st = st2, st1 = st2.

Proof.
intros st st1 st2 H1 H2 st0 H0 H3 st3 H4 H5.
(* We first prove that st1 = st3 *)
  assert (H6 : st1 = st3) as H6.
{
    apply H0;
    apply H3;
    apply H4.
}
  (* We then prove that st1 = st2 *)
  assert (H7 : st1 = st2) as H7.
{
    apply H5;
    apply H6.
}
  (* Finally, we prove that st1 = st2 *)
  apply H7.
Qed.

Outdated contents in ..cache: recomputing
ERROR MESSAGE IN LEMMA PROOF (FRAGMENT #464)
Error after step "intros st st1 st2 H1 H2 st0 H0 H3 st3 H4 H5.".
Message: There are still unproven goals.
Goal: st1 = st2.


TRYING TO PROVE LEMMA
Lemma state_equality_preserved_by_skip_transition_4 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, forall st0 : state, forall H0 : st0 = st, forall H3 : st = st1, forall st3 : state, forall H4 : st3 = st, forall H5 : st = st2, st1 = st2.


ATTEMPTED LEMMA PROOF (LEMMAS USED: 5)







From Coq Require Import Lia.
From Coq Require Import Arith.Arith.
From Coq Require Import Arith.PeanoNat.
Import Nat.
From Coq Require Import Arith.EqNat.
From LF Require Import Imp Maps.



Fixpoint ceval_step1 (st : state) (c : com) : state :=
  match c with
    | <{ skip }> =>
        st
    | <{ l := a1 }> =>
        (l !-> aeval st a1 ; st)
    | <{ c1 ; c2 }> =>
        let st' := ceval_step1 st c1 in
        ceval_step1 st' c2
    | <{ if b then c1 else c2 end }> =>
        if (beval st b)
          then ceval_step1 st c1
          else ceval_step1 st c2
    | <{ while b1 do c1 end }> =>
        st  
  end.








Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=
  match i with
  | O => empty_st
  | S i' =>
    match c with
      | <{ skip }> =>
          st
      | <{ l := a1 }> =>
          (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          let st' := ceval_step2 st c1 i' in
          ceval_step2 st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step2 st c1 i'
            else ceval_step2 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then let st' := ceval_step2 st c1 i' in
               ceval_step2 st' c i'
          else st
    end
  end.



Fixpoint ceval_step3 (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          match (ceval_step3 st c1 i') with
          | Some st' => ceval_step3 st' c2 i'
          | None => None
          end
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step3 st c1 i'
            else ceval_step3 st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then match (ceval_step3 st c1 i') with
               | Some st' => ceval_step3 st' c i'
               | None => None
               end
          else Some st
    end
  end.



Notation "'LETOPT' x <== e1 'IN' e2"
   := (match e1 with
         | Some x => e2
         | None => None
       end)
   (right associativity, at level 60).

Fixpoint ceval_step (st : state) (c : com) (i : nat)
                    : option state :=
  match i with
  | O => None
  | S i' =>
    match c with
      | <{ skip }> =>
          Some st
      | <{ l := a1 }> =>
          Some (l !-> aeval st a1 ; st)
      | <{ c1 ; c2 }> =>
          LETOPT st' <== ceval_step st c1 i' IN
          ceval_step st' c2 i'
      | <{ if b then c1 else c2 end }> =>
          if (beval st b)
            then ceval_step st c1 i'
            else ceval_step st c2 i'
      | <{ while b1 do c1 end }> =>
          if (beval st b1)
          then LETOPT st' <== ceval_step st c1 i' IN
               ceval_step st' c i'
          else Some st
    end
  end.

Definition test_ceval (st:state) (c:com) :=
  match ceval_step st c 500 with
  | None    => None
  | Some st => Some (st X, st Y, st Z)
  end.

Example example_test_ceval :
     test_ceval empty_st

     <{ X := 2;
        if (X <= 1)
        then Y := 3
        else Z := 4
        end }>

     = Some (2, 0, 4).
Proof. reflexivity. Qed.



Definition pup_to_n : com
  := <{ Y := 0;
        while X > 0 do
          Y := Y + X;
          X := X - 1
        end }>.

Example pup_to_n_1 :
  test_ceval (X !-> 5) pup_to_n
  = Some (0, 15, 0).
Proof. reflexivity. Qed.




Definition peven : com
  := <{ Z := 0;
        while X > 0 do
          if Z = 0 then Z := 1 else Z := 0 end;
          X := X - 1
        end }>.

Example peven0 :
  test_ceval (X !-> 0) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven1 :
  test_ceval (X !-> 1) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven2 :
  test_ceval (X !-> 2) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.

Example peven3 :
  test_ceval (X !-> 3) peven = Some (0, 0, 1).
Proof. reflexivity. Qed.

Example peven4 :
  test_ceval (X !-> 4) peven = Some (0, 0, 0).
Proof. reflexivity. Qed.






Theorem ceval_step__ceval: forall c st st',
      (exists i, ceval_step st c i = Some st') ->
      st =[ c ]=> st'.
Proof.
  intros c st st' H.
  inversion H as [i E].
  clear H.
  generalize dependent st'.
  generalize dependent st.
  generalize dependent c.
  induction i as [| i' ].

  - 
    intros c st st' H. discriminate H.

  - 
    intros c st st' H.
    destruct c;
           simpl in H; inversion H; subst; clear H.
      +  apply E_Skip.
      +  apply E_Asgn. reflexivity.

      + 
        destruct (ceval_step st c1 i') eqn:Heqr1.
        * 
          apply E_Seq with s.
            apply IHi'. rewrite Heqr1. reflexivity.
            apply IHi'. assumption.
        * 
          discriminate H1.

      + 
        destruct (beval st b) eqn:Heqr.
        * 
          apply E_IfTrue. rewrite Heqr. reflexivity.
          apply IHi'. assumption.
        * 
          apply E_IfFalse. rewrite Heqr. reflexivity.
          apply IHi'. assumption.

      +  destruct (beval st b) eqn :Heqr.
        * 
         destruct (ceval_step st c i') eqn:Heqr1.
         { 
           apply E_WhileTrue with s. rewrite Heqr.
           reflexivity.
           apply IHi'. rewrite Heqr1. reflexivity.
           apply IHi'. assumption. }
         {  discriminate H1. }
        * 
          injection H1 as H2. rewrite <- H2.
          apply E_WhileFalse. apply Heqr. Qed.






Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None.


Theorem ceval_step_more: forall i1 i2 st st' c,
  i1 <= i2 ->
  ceval_step st c i1 = Some st' ->
  ceval_step st c i2 = Some st'.
Proof.
induction i1 as [|i1']; intros i2 st st' c Hle Hceval.
  - 
    simpl in Hceval. discriminate Hceval.
  - 
    destruct i2 as [|i2']. inversion Hle.
    assert (Hle': i1' <= i2') by lia.
    destruct c.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. inversion Hceval.
      reflexivity.
    + 
      simpl in Hceval. simpl.
      destruct (ceval_step st c1 i1') eqn:Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        discriminate Hceval.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); apply (IHi1' i2') in Hceval;
        assumption.

    + 
      simpl in Hceval. simpl.
      destruct (beval st b); try assumption.
      destruct (ceval_step st c i1') eqn: Heqst1'o.
      * 
        apply (IHi1' i2') in Heqst1'o; try assumption.
        rewrite -> Heqst1'o. simpl. simpl in Hceval.
        apply (IHi1' i2') in Hceval; try assumption.
      * 
        simpl in Hceval. discriminate Hceval.  Qed.



Theorem ceval__ceval_step: forall c st st',
      st =[ c ]=> st' ->
      exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st' Hce.
  induction Hce.
  - exists 1. reflexivity.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2].
    exists (S i + j).
    assert (H: ceval_step st c1 (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    simpl. rewrite H. apply ceval_step_more with (i1:=j).
    rewrite plus_comm. apply le_plus_l. apply IH2.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - destruct IHHce as [i IH]. exists (S i). simpl. rewrite H. apply IH.
  - exists 1. simpl. rewrite H. reflexivity.
  - destruct IHHce1 as [i IH1]. destruct IHHce2 as [j IH2]. exists (S i + j). simpl. rewrite H.
    assert (G: ceval_step st c (i + j) = Some st').
    apply ceval_step_more with (i1:=i). apply le_plus_l. apply IH1.
    rewrite G. apply ceval_step_more with (i1:=j). apply le_plus_r. apply IH2.
Qed.


Theorem ceval_and_ceval_step_coincide: forall c st st',
      st =[ c ]=> st'
  <-> exists i, ceval_step st c i = Some st'.
Proof.
  intros c st st'.
  split. apply ceval__ceval_step. apply ceval_step__ceval.
Qed.








Lemma state_equality_preserved_by_skip_transition_4 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, forall st0 : state, forall H0 : st0 = st, forall H3 : st = st1, forall st3 : state, forall H4 : st3 = st, forall H5 : st = st2, st1 = st2.

Proof.
intros st st1 st2 H1 H2 st0 H0 H3 st3 H4 H5.
(* We first prove that st1 = st3 *)
  assert (H6 : st1 = st3) as H6.
{
    apply H0;
    apply H3;
    apply H4.
}
  (* We then prove that st2 = st3 *)
  assert (H7 : st2 = st3) as H7.
{
    apply H5;
    apply H3;
    apply H4.
}
  (* We now prove that st1 = st2 *)
  apply H6;
  apply H7.
Qed.

Outdated contents in ..cache: recomputing
ERROR MESSAGE IN LEMMA PROOF (FRAGMENT #464)
Error after step "intros st st1 st2 H1 H2 st0 H0 H3 st3 H4 H5.".
Message: There are still unproven goals.
Goal: st1 = st2.


TRYING TO PROVE LEMMA
Lemma state_equality_preserved_by_skip_transition_5 : forall st st1 st2 : state, forall H1 : st =[ skip ]=> st1, forall H2 : st =[ skip ]=> st2, forall st0 : state, forall H0 : st0 = st, forall H3 : st = st1, forall st3 : state, forall H4 : st3 = st, forall H5 : st = st2, st1 = st2.


Error proving ceval_deterministic'
MAX LEMMA DEPTH REACHED. GIVING UP.